
[轻松搞定面试中的二叉树问题](http://blog.csdn.net/luckyxiaoqiang/article/details/7518888)

[二叉树的各种递归非递归实现](http://blog.csdn.net/beitiandijun/article/category/1298621)

层数(深度)高度:从1开始

度数 + 1 = 结点数

二叉树不能说就是树，树的结点至少为1，度数没有限制,而二叉树的结点数是可以为0的
## 认识二叉树
### 性质：
   1. 非空二叉树第k层结点最多为**2^(k-1)** 个结点
   2. 高度为 K 的二叉树中，总共最多有 **2^k - 1** 个结点
   3. 非空二叉树普遍情况下,**n0 = n2 + 1**

### 完全二叉树：
   只有最下面两层结点度<2,也就是：如果没有最后一层，那么它将是一个满二叉树，</br>
   最后一层结点都分布在左边</br>
   共有n个结点，则深度为**log2(n)+1**</br>
   深度为k的完全二叉树，至少有**2^(k-1)**,至多有**2^k-1**<so,满二叉树是完全二叉树>

### 满二叉树：
   深度为k，且最多有2^k-1个结点,可以知道，其每一层节点数都是最大节点数</br>
   深度为 k 的完全二叉树去掉第K层就变为满二叉树了
       可以看出完全二叉树和满二叉树的关系

### 扩充二叉树：
   添加外层结点，把原树中度数<2的结点都补为2</br>
   外部结点个数 N 内部结点个数 n     **N - n = 1**</br>
   外部路径 E 内部路径 I             **E - I = 2n**</br>

### 平衡二叉树
   其左右子树都是平衡二叉树，左右子树的高度的绝对值<=1


## 二叉树的遍历

### 二叉树还原
* 先+中
    根据终先序找到第一个根后，就可以在中序中将序列分成左右两部分,对分开后的两部分也这样分析就可以还原了
* 中+后
    方法和上面差不多，后序中最后一个元素就是根,倒数第二个就是根右边的儿子
* 先+后
   无解,只能确定父子关系而已

### 二叉树的存储
1. 数组
   如果用数组来存储的话，可以根据父子结点的位置关系来确定一颗二叉树<如果子节点为i则富结点为i/2>
   但是无论如何都得按照完全二叉树的空间来分配即:2^k-1,很明显太浪费
   . 如果将一个算式存到二叉树那么先中后序遍历得到的式子刚好就是前缀中缀后缀

2. 链式存储
   [data][llink][rlink]

有空找找二叉树的选择题看看。


### 二叉排序树
* 结点间是左小右大，子树也是二叉排序树, 结点元素是唯一的
* 插入删除都不改变树的结构
* 经过中序遍历后得到的是递增的序列(所以插入的时候，不可以在中间插入，必须遍历完,找到的位置一般都是末尾)
* 根始终大于左子树，小于右子树
* 子树也是二叉排序树

#### 删除
* 所删结点为叶节点
* 所删结点左/右子树空
* 所删结点左右子树都非空

### 优先队列
* 和队列一样，队尾进,队头出。不同的是队列中的最大/小元素总是位于对首，所以并非先进先出，而是最大/小的元素先出。

### 线索二叉树
* 为了充分利用空指针,如果有儿子，指针就指向儿子,否则，作为线索只想前驱或后继结点。

### 哈夫曼树(最优二叉树)
* `WPL`

